package ext

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"pig/internal/config"
	"pig/internal/output"
	"pig/internal/utils"
	"regexp"
	"strconv"

	"github.com/sirupsen/logrus"
)

const (
	pgLinkPath    = "/usr/pgsql"
	pgProfilePath = "/etc/profile.d/pgsql.sh"
	minPGVersion  = 10
	maxPGVersion  = 30
)

var (
	unlinkKeywords = map[string]bool{"null": true, "none": true, "nil": true, "nop": true, "no": true}
	systemPaths    = map[string]bool{"/": true, "/usr": true, "/usr/local": true}
)

// UnlinkPostgres unlinks the current PostgreSQL:
// 1. Removes the /usr/pgsql symbolic link
// 2. Removes the /etc/profile.d/pgsql.sh file
func UnlinkPostgres() error {
	logrus.Debugf("unlinking postgres from environment")

	if err := RemoveSymlink(pgLinkPath); err != nil {
		return fmt.Errorf("failed to remove symlink %s: %w", pgLinkPath, err)
	}

	if err := utils.DelFile(pgProfilePath); err != nil {
		return fmt.Errorf("failed to remove profile %s: %w", pgProfilePath, err)
	}

	logrus.Infof("postgres unlinked")
	return nil
}

// RemoveSymlink removes a symbolic link if it exists and is actually a symlink
func RemoveSymlink(path string) error {
	info, err := os.Lstat(path)
	if os.IsNotExist(err) {
		return nil
	}
	if err != nil {
		return fmt.Errorf("failed to check symlink %s: %w", path, err)
	}
	if info.Mode()&os.ModeSymlink == 0 {
		return fmt.Errorf("path %s exists but is not a symbolic link", path)
	}
	return utils.DelFile(path)
}

// resolvePGHome determines the PostgreSQL home directory based on version or path
func resolvePGHome(arg string) (string, error) {
	// Check if it's a version number
	if ver, err := strconv.Atoi(arg); err == nil {
		if ver < minPGVersion || ver > maxPGVersion {
			return "", fmt.Errorf("invalid PostgreSQL version: %d (must be between %d and %d)",
				ver, minPGVersion, maxPGVersion)
		}

		switch config.OSType {
		case config.DistroEL:
			return fmt.Sprintf("/usr/pgsql-%d", ver), nil
		case config.DistroDEB:
			return fmt.Sprintf("/usr/lib/postgresql/%d", ver), nil
		default:
			return "", fmt.Errorf("unsupported OS distribution: %s", config.OSType)
		}
	}

	// Otherwise, treat as direct path
	return arg, nil
}

// validatePGHome checks if the given path is a valid PostgreSQL installation
func validatePGHome(pgHome string) error {
	if systemPaths[pgHome] {
		return fmt.Errorf("cannot use system path %s as PostgreSQL home", pgHome)
	}

	info, err := os.Stat(pgHome)
	if err != nil || !info.IsDir() {
		return fmt.Errorf("PGHOME directory %s is not valid: %s", pgHome, err)
	}

	binDir := filepath.Join(pgHome, "bin")
	binInfo, err := os.Stat(binDir)
	if err != nil || !binInfo.IsDir() {
		return fmt.Errorf("bin directory %s is not valid: %s", binDir, err)
	}

	return nil
}

// generateProfile creates the profile script content
func generateProfile(pgHome, binDir string) []byte {
	var buf bytes.Buffer
	buf.WriteString("# generated by pig\n")
	buf.WriteString(fmt.Sprintf("export PATH=\"%s:$PATH\"\n", binDir))
	buf.WriteString(fmt.Sprintf("export PGHOME=\"%s\"\n", pgHome))
	return buf.Bytes()
}

// LinkPostgresResult returns a structured Result for the ext link command
func LinkPostgresResult(args ...string) *output.Result {
	if len(args) != 1 {
		return output.Fail(output.CodeExtensionLinkFailed, fmt.Sprintf("exactly one argument required, got %d", len(args)))
	}

	arg := args[0]

	// Handle unlink case
	if unlinkKeywords[arg] {
		if err := UnlinkPostgres(); err != nil {
			return output.Fail(output.CodeExtensionLinkFailed, err.Error())
		}
		data := &LinkResultData{
			Action:      "unlink",
			SymlinkPath: pgLinkPath,
			ProfilePath: pgProfilePath,
		}
		return output.OK("PostgreSQL unlinked", data)
	}

	// Handle pg<version> format (e.g., pg17, pg18)
	pgVersionPattern := regexp.MustCompile(`^pg(\d+)$`)
	if matches := pgVersionPattern.FindStringSubmatch(arg); matches != nil {
		arg = matches[1] // Extract the version number
		logrus.Debugf("remove %s pg prefix and use %s as pg version", args[0], arg)
	}

	// Resolve and validate PGHOME
	pgHome, err := resolvePGHome(arg)
	if err != nil {
		return output.Fail(output.CodeExtensionLinkFailed, err.Error())
	}

	if err := validatePGHome(pgHome); err != nil {
		return output.Fail(output.CodeExtensionLinkFailed, err.Error())
	}

	// Create symlink
	if err := RemoveSymlink(pgLinkPath); err != nil {
		return output.Fail(output.CodeExtensionLinkFailed, fmt.Sprintf("failed to remove existing symlink: %v", err))
	}
	if err := utils.SudoCommand([]string{"ln", "-s", pgHome, pgLinkPath}); err != nil {
		return output.Fail(output.CodeExtensionLinkFailed, fmt.Sprintf("failed to create symlink %s -> %s: %v", pgLinkPath, pgHome, err))
	}

	// Write profile
	binDir := filepath.Join(pgHome, "bin")
	if err := utils.PutFile(pgProfilePath, generateProfile(pgHome, binDir)); err != nil {
		return output.Fail(output.CodeExtensionLinkFailed, fmt.Sprintf("failed to write profile %s: %v", pgProfilePath, err))
	}

	data := &LinkResultData{
		Action:       "link",
		PgHome:       pgHome,
		SymlinkPath:  pgLinkPath,
		ProfilePath:  pgProfilePath,
		ActivatedCmd: fmt.Sprintf(". %s", pgProfilePath),
	}

	message := fmt.Sprintf("PostgreSQL linked: %s -> %s", pgLinkPath, pgHome)
	return output.OK(message, data)
}

// LinkPostgres links or unlinks PostgreSQL based on the given arguments.
// Usage:
// 1) LinkPostgres("none")             -> Unlink
// 2) LinkPostgres("14")               -> Link to system default path
// 3) LinkPostgres("pg17")             -> Link to PostgreSQL 17 (strip pg prefix)
// 4) LinkPostgres("/custom/pg/path")  -> Link to custom directory
func LinkPostgres(args ...string) error {
	if len(args) != 1 {
		return fmt.Errorf("exactly one argument required, got %d", len(args))
	}

	arg := args[0]
	if unlinkKeywords[arg] {
		return UnlinkPostgres()
	}

	// Handle pg<version> format (e.g., pg17, pg18)
	pgVersionPattern := regexp.MustCompile(`^pg(\d+)$`)
	if matches := pgVersionPattern.FindStringSubmatch(arg); matches != nil {
		arg = matches[1] // Extract the version number
		logrus.Debugf("remove %s pg prefix and use %s as pg version", args[0], arg)
	}

	// Resolve and validate PGHOME
	pgHome, err := resolvePGHome(arg)
	if err != nil {
		return err
	}

	if err := validatePGHome(pgHome); err != nil {
		logrus.Warnf("postgres home validation failed: %s", err)
	}

	// Create symlink
	if err := RemoveSymlink(pgLinkPath); err != nil {
		return fmt.Errorf("failed to remove existing symlink: %w", err)
	}
	if err := utils.SudoCommand([]string{"ln", "-s", pgHome, pgLinkPath}); err != nil {
		return fmt.Errorf("failed to create symlink %s -> %s: %w", pgLinkPath, pgHome, err)
	}
	logrus.Infof("symlink created: %s -> %s", pgLinkPath, pgHome)

	// Write profile
	binDir := filepath.Join(pgHome, "bin")
	if err := utils.PutFile(pgProfilePath, generateProfile(pgHome, binDir)); err != nil {
		return fmt.Errorf("failed to write profile %s: %w", pgProfilePath, err)
	}

	logrus.Infof("profile updated: %s (PGHOME=%s)", pgProfilePath, pgHome)
	logrus.Infof("run this command to activate PATH in your current session:")
	logrus.Warnf("$ . %s", pgProfilePath)
	return nil
}
